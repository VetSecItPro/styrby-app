/**
 * Cost Data Fetching Library
 *
 * Server-side utilities for fetching and aggregating cost data from Supabase.
 * Uses the `cost_records` table and `mv_daily_cost_summary` materialized view.
 *
 * ## Data Flow
 *
 * ```
 * CLI (cost-reporter) --> Supabase (cost_records) --> Web (this module)
 *                                                       |
 *                                                       v
 *                                                  Dashboard Components
 * ```
 *
 * ## Performance
 *
 * - Fetches are scoped by user via RLS
 * - Date filtering uses BRIN-indexed `record_date` column
 * - For dashboard, use `fetchAllCostSummaries()` to parallelize queries
 *
 * @module lib/costs
 */

import { SupabaseClient } from '@supabase/supabase-js';

// ============================================================================
// Types
// ============================================================================

/**
 * Agent types supported by Styrby.
 *
 * WHY: Matches the agent_type column in cost_records table.
 */
export type AgentType = 'claude' | 'codex' | 'gemini' | 'opencode';

/**
 * Time period options for cost aggregation.
 */
export type CostPeriod = 'today' | 'week' | 'month' | 'all';

/**
 * Cost summary for a time period.
 *
 * Represents aggregated token counts and cost for a dashboard card.
 */
export interface CostSummary {
  /** Total cost in USD */
  totalCost: number;
  /** Total input tokens */
  inputTokens: number;
  /** Total output tokens */
  outputTokens: number;
  /** Total cache read tokens */
  cacheReadTokens: number;
  /** Total cache write tokens */
  cacheWriteTokens: number;
  /** Number of API requests */
  requestCount: number;
}

/**
 * Cost breakdown by agent type.
 *
 * Used for the agent breakdown chart on the dashboard.
 */
export interface AgentCostBreakdown {
  /** Agent identifier */
  agent: AgentType;
  /** Total cost for this agent in USD */
  cost: number;
  /** Input tokens consumed by this agent */
  inputTokens: number;
  /** Output tokens generated by this agent */
  outputTokens: number;
  /** Number of requests made to this agent */
  requestCount: number;
  /** Percentage of total cost (0-100) */
  percentage: number;
}

/**
 * Cost breakdown by model.
 *
 * Used for the detailed cost table on the dashboard.
 */
export interface ModelCostBreakdown {
  /** Model identifier (e.g., 'claude-sonnet-4-20250514') */
  model: string;
  /** Which agent uses this model */
  agent: AgentType;
  /** Total cost for this model in USD */
  cost: number;
  /** Input tokens consumed */
  inputTokens: number;
  /** Output tokens generated */
  outputTokens: number;
  /** Number of requests */
  requestCount: number;
}

/**
 * Daily cost data point for time-series charts.
 *
 * Includes total and per-agent breakdown for stacked charts.
 */
export interface DailyCostDataPoint {
  /** Date string in YYYY-MM-DD format */
  date: string;
  /** Total cost for this day */
  total: number;
  /** Cost from Claude Code */
  claude: number;
  /** Cost from Codex */
  codex: number;
  /** Cost from Gemini CLI */
  gemini: number;
  /** Cost from OpenCode */
  opencode: number;
}

// ============================================================================
// Period Calculation
// ============================================================================

/**
 * Get the start date for a given period.
 *
 * @param period - The time period to calculate start date for
 * @returns Date object representing the start of the period (midnight local time)
 *
 * @example
 * const weekStart = getPeriodStartDate('week');
 * // Returns date 7 days ago at midnight
 */
export function getPeriodStartDate(period: CostPeriod): Date {
  const now = new Date();
  const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  switch (period) {
    case 'today':
      return startOfDay;
    case 'week':
      const weekAgo = new Date(startOfDay);
      weekAgo.setDate(weekAgo.getDate() - 7);
      return weekAgo;
    case 'month':
      const monthAgo = new Date(startOfDay);
      monthAgo.setDate(monthAgo.getDate() - 30);
      return monthAgo;
    case 'all':
      return new Date(0); // Beginning of time
    default:
      return startOfDay;
  }
}

// ============================================================================
// Data Fetching
// ============================================================================

/**
 * Fetch cost summary for a time period.
 *
 * Aggregates all cost records for the authenticated user within the period.
 *
 * @param supabase - Supabase client instance (with auth context)
 * @param period - Time period to fetch costs for
 * @returns Cost summary with totals
 *
 * @example
 * const todayCosts = await fetchCostSummary(supabase, 'today');
 * console.log(`Spent today: $${todayCosts.totalCost.toFixed(2)}`);
 */
export async function fetchCostSummary(
  supabase: SupabaseClient,
  period: CostPeriod
): Promise<CostSummary> {
  const startDate = getPeriodStartDate(period);

  const query = supabase
    .from('cost_records')
    .select(
      'cost_usd, input_tokens, output_tokens, cache_read_tokens, cache_write_tokens'
    );

  if (period !== 'all') {
    query.gte('record_date', startDate.toISOString().split('T')[0]);
  }

  const { data, error } = await query;

  if (error) {
    console.error('Error fetching cost summary:', error);
    return {
      totalCost: 0,
      inputTokens: 0,
      outputTokens: 0,
      cacheReadTokens: 0,
      cacheWriteTokens: 0,
      requestCount: 0,
    };
  }

  return (data || []).reduce(
    (acc, record) => ({
      totalCost: acc.totalCost + (Number(record.cost_usd) || 0),
      inputTokens: acc.inputTokens + (record.input_tokens || 0),
      outputTokens: acc.outputTokens + (record.output_tokens || 0),
      cacheReadTokens: acc.cacheReadTokens + (record.cache_read_tokens || 0),
      cacheWriteTokens: acc.cacheWriteTokens + (record.cache_write_tokens || 0),
      requestCount: acc.requestCount + 1,
    }),
    {
      totalCost: 0,
      inputTokens: 0,
      outputTokens: 0,
      cacheReadTokens: 0,
      cacheWriteTokens: 0,
      requestCount: 0,
    }
  );
}

/**
 * Fetch cost breakdown by agent.
 *
 * Groups cost records by agent type and calculates percentages.
 *
 * @param supabase - Supabase client instance (with auth context)
 * @param days - Number of days to look back (default: 30)
 * @returns Array of agent cost breakdowns sorted by cost descending
 *
 * @example
 * const agentCosts = await fetchCostsByAgent(supabase, 30);
 * // [{ agent: 'claude', cost: 45.50, percentage: 85.2, ... }, ...]
 */
export async function fetchCostsByAgent(
  supabase: SupabaseClient,
  days: number = 30
): Promise<AgentCostBreakdown[]> {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  const { data, error } = await supabase
    .from('cost_records')
    .select('agent_type, cost_usd, input_tokens, output_tokens')
    .gte('record_date', startDate.toISOString().split('T')[0]);

  if (error) {
    console.error('Error fetching costs by agent:', error);
    return [];
  }

  // Aggregate by agent
  const agentMap = new Map<string, Omit<AgentCostBreakdown, 'percentage'>>();

  for (const record of data || []) {
    const agent = (record.agent_type || 'unknown') as AgentType;
    const existing = agentMap.get(agent) || {
      agent,
      cost: 0,
      inputTokens: 0,
      outputTokens: 0,
      requestCount: 0,
    };

    agentMap.set(agent, {
      agent,
      cost: existing.cost + (Number(record.cost_usd) || 0),
      inputTokens: existing.inputTokens + (record.input_tokens || 0),
      outputTokens: existing.outputTokens + (record.output_tokens || 0),
      requestCount: existing.requestCount + 1,
    });
  }

  // Calculate percentages and sort by cost descending
  const totalCost = Array.from(agentMap.values()).reduce((sum, a) => sum + a.cost, 0);
  const results: AgentCostBreakdown[] = Array.from(agentMap.values())
    .map((a) => ({
      ...a,
      percentage: totalCost > 0 ? (a.cost / totalCost) * 100 : 0,
    }))
    .sort((a, b) => b.cost - a.cost);

  return results;
}

/**
 * Fetch cost breakdown by model.
 *
 * Groups cost records by model name for detailed analysis.
 *
 * @param supabase - Supabase client instance (with auth context)
 * @param days - Number of days to look back (default: 30)
 * @returns Array of model cost breakdowns sorted by cost descending
 *
 * @example
 * const modelCosts = await fetchCostsByModel(supabase);
 * // [{ model: 'claude-sonnet-4-20250514', cost: 30.00, ... }, ...]
 */
export async function fetchCostsByModel(
  supabase: SupabaseClient,
  days: number = 30
): Promise<ModelCostBreakdown[]> {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  const { data, error } = await supabase
    .from('cost_records')
    .select('agent_type, model, cost_usd, input_tokens, output_tokens')
    .gte('record_date', startDate.toISOString().split('T')[0]);

  if (error) {
    console.error('Error fetching costs by model:', error);
    return [];
  }

  // Aggregate by model
  const modelMap = new Map<string, ModelCostBreakdown>();

  for (const record of data || []) {
    const model = record.model || 'unknown';
    const existing = modelMap.get(model) || {
      model,
      agent: (record.agent_type || 'unknown') as AgentType,
      cost: 0,
      inputTokens: 0,
      outputTokens: 0,
      requestCount: 0,
    };

    modelMap.set(model, {
      ...existing,
      cost: existing.cost + (Number(record.cost_usd) || 0),
      inputTokens: existing.inputTokens + (record.input_tokens || 0),
      outputTokens: existing.outputTokens + (record.output_tokens || 0),
      requestCount: existing.requestCount + 1,
    });
  }

  return Array.from(modelMap.values()).sort((a, b) => b.cost - a.cost);
}

/**
 * Fetch daily cost data for time-series charts.
 *
 * Returns one data point per day with total and per-agent breakdown.
 *
 * @param supabase - Supabase client instance (with auth context)
 * @param days - Number of days to look back (default: 30)
 * @returns Array of daily cost data points sorted by date ascending
 *
 * @example
 * const dailyCosts = await fetchDailyCosts(supabase, 14);
 * // [{ date: '2025-01-01', total: 5.00, claude: 4.50, ... }, ...]
 */
export async function fetchDailyCosts(
  supabase: SupabaseClient,
  days: number = 30
): Promise<DailyCostDataPoint[]> {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  const { data, error } = await supabase
    .from('cost_records')
    .select('record_date, agent_type, cost_usd')
    .gte('record_date', startDate.toISOString().split('T')[0])
    .order('record_date', { ascending: true });

  if (error) {
    console.error('Error fetching daily costs:', error);
    return [];
  }

  // Aggregate by date and agent
  const dateMap = new Map<string, DailyCostDataPoint>();

  for (const record of data || []) {
    const date = record.record_date;
    const existing = dateMap.get(date) || {
      date,
      total: 0,
      claude: 0,
      codex: 0,
      gemini: 0,
      opencode: 0,
    };

    const cost = Number(record.cost_usd) || 0;
    existing.total += cost;

    switch (record.agent_type) {
      case 'claude':
        existing.claude += cost;
        break;
      case 'codex':
        existing.codex += cost;
        break;
      case 'gemini':
        existing.gemini += cost;
        break;
      default:
        // Handle opencode or unknown agents
        existing.opencode += cost;
    }

    dateMap.set(date, existing);
  }

  return Array.from(dateMap.values()).sort(
    (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
  );
}

/**
 * Fetch all cost summaries in parallel for dashboard.
 *
 * More efficient than calling fetchCostSummary multiple times sequentially.
 *
 * @param supabase - Supabase client instance (with auth context)
 * @returns Object containing today, week, month, and all-time cost summaries
 *
 * @example
 * const { today, week, month, allTime } = await fetchAllCostSummaries(supabase);
 */
export async function fetchAllCostSummaries(supabase: SupabaseClient): Promise<{
  today: CostSummary;
  week: CostSummary;
  month: CostSummary;
  allTime: CostSummary;
}> {
  const [today, week, month, allTime] = await Promise.all([
    fetchCostSummary(supabase, 'today'),
    fetchCostSummary(supabase, 'week'),
    fetchCostSummary(supabase, 'month'),
    fetchCostSummary(supabase, 'all'),
  ]);

  return { today, week, month, allTime };
}

// ============================================================================
// Formatting Utilities
// ============================================================================

/**
 * Format cost as USD currency string.
 *
 * @param cost - Cost value in USD
 * @param decimals - Number of decimal places (default: 2)
 * @returns Formatted currency string like "$12.50"
 *
 * @example
 * formatCost(12.5)     // "$12.50"
 * formatCost(0.0042, 4) // "$0.0042"
 */
export function formatCost(cost: number, decimals: number = 2): string {
  return `$${cost.toFixed(decimals)}`;
}

/**
 * Format token count with K/M suffix for readability.
 *
 * @param tokens - Number of tokens
 * @returns Formatted token string like "1.5K" or "2.3M"
 *
 * @example
 * formatTokens(500)      // "500"
 * formatTokens(1500)     // "1.5K"
 * formatTokens(1500000)  // "1.5M"
 */
export function formatTokens(tokens: number): string {
  if (tokens >= 1_000_000) {
    return `${(tokens / 1_000_000).toFixed(1)}M`;
  }
  if (tokens >= 1_000) {
    return `${(tokens / 1_000).toFixed(1)}K`;
  }
  return tokens.toString();
}

// ============================================================================
// Color Utilities
// ============================================================================

/**
 * Get Tailwind CSS background color class for an agent.
 *
 * @param agent - Agent type
 * @returns Tailwind CSS class like "bg-orange-500"
 *
 * @example
 * <div className={getAgentColor('claude')} /> // bg-orange-500
 */
export function getAgentColor(agent: AgentType): string {
  switch (agent) {
    case 'claude':
      return 'bg-orange-500';
    case 'codex':
      return 'bg-green-500';
    case 'gemini':
      return 'bg-blue-500';
    case 'opencode':
      return 'bg-purple-500';
    default:
      return 'bg-zinc-500';
  }
}

/**
 * Get hex color code for an agent (for charts/SVGs).
 *
 * @param agent - Agent type
 * @returns Hex color code like "#f97316"
 *
 * @example
 * const color = getAgentHexColor('claude'); // "#f97316"
 */
export function getAgentHexColor(agent: AgentType): string {
  switch (agent) {
    case 'claude':
      return '#f97316'; // orange-500
    case 'codex':
      return '#22c55e'; // green-500
    case 'gemini':
      return '#3b82f6'; // blue-500
    case 'opencode':
      return '#a855f7'; // purple-500
    default:
      return '#71717a'; // zinc-500
  }
}
